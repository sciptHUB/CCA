---
title: "CCA-Heterogeneity Biomarker Discovery Part 2"
author: "Pat Kueanjinda"
date: "July 12, 2018"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r}
library(dplyr)
library(tidyr)
library(xlsx)
```

```{r}
setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq')

df.input <- read.csv('UseThis4_Biomarkers.csv', header = TRUE, stringsAsFactors = FALSE)

# download expression level
df.explevel <- read.csv('Expression_level_ALL.csv', header = TRUE, stringsAsFactors = FALSE)

# download drug response
df.DR <- read.csv('Median_centered_GR50_26062018.csv', header = TRUE, stringsAsFactors = FALSE)
```

Pseudocodes
1. obtain leading edge genes
2. extract expression level of the selected genes
3. clustering into clusters
4. from each cluster, sample genes for predictive drug response (using SVM) into training and testing sets
5. obtain accuracy of prediction from each gene sets in the cluster
6. list candidate genes for each cluster

```{r}
# 1. Obtain leading edge genes
# Subset data into positive NES and negative NES only from 'Subtype_1.2' set
df.pos <- df.input %>% subset(Cell %in% 'Subtype_1.2' & NES > 0)
df.neg <- df.input %>% subset(Cell %in% 'Subtype_1.2' & NES <= 0)
```

```{r}
S1 <- c('K213','K214','K156','HUCCA1','RBE','D138','HUH28')
S2 <- c('K055','D068','K100','TFK1','YSCCC','HuCCT1','D131','SSP25')
S.all <- c(S1,S2)
# construct a matrix containing Genes, Hallmarks,NES value status (positive)
fp <- lapply(1:length(S.all), function(j) {
  cp <- lapply(1:nrow(df.pos), function(i) {
    gnls <- df.pos$core_enrichment[i]
    # extract gene name using '/'
    n <- strsplit(gnls, "/")
    dn <- do.call(cbind,n)
    dh <- data.frame('Gene' = dn,
                     'Hallmark' = rep(df.pos$ID[i],length(dn)),
                     'HM.category' = rep(df.pos$HM.category[i], length(dn)),
                     'HM.cat.color' = rep(df.pos$HM.color[i], length(dn)),
                     'NES.status' = rep('positive',length(dn)),
                     'NES.value' = rep(1,length(dn)),
                     'Cell' = rep(S.all[j],length(dn)))
  })
  
  dp <- do.call(rbind,cp)
  
})

ffp <- do.call(rbind,fp)

#####
# construct a matrix containing Genes, Hallmarks,NES value status (negative)
fn <- lapply(1:length(S.all), function(j) {
  cn <- lapply(1:nrow(df.neg), function(i) {
    gnls <- df.neg$core_enrichment[i]
    # extract gene name using '/'
    n <- strsplit(gnls, "/")
    dn <- do.call(cbind,n)
    dh <- data.frame('Gene' = dn,
                     'Hallmark' = rep(df.neg$ID[i],length(dn)),
                     'HM.category' = rep(df.neg$HM.category[i], length(dn)),
                     'HM.cat.color' = rep(df.neg$HM.color[i], length(dn)),
                     'NES.status' = rep('negative',length(dn)),
                     'NES.value' = rep(-1,length(dn)),
                     'Cell' = rep(S.all[j],length(dn)))
  })
  
  dn <- do.call(rbind,cn)
  
})

ffn <- do.call(rbind,fn)
```

```{r}
# 2. Extract expression level for leading edge genes
# add expression level based on gene matching
library(reshape2)
exp.cast <- melt(df.explevel, id.vars = 'X',
                 variable.name = 'Cell',
                 value.name = 'Exp.level')

ffp2 <- ffp %>% rowwise() %>% mutate(Explevel.value = exp.cast$Exp.level[which(Cell == exp.cast$Cell & Gene == exp.cast$X)])
  
ffn2 <- ffn %>% rowwise() %>% mutate(Explevel.value = exp.cast$Exp.level[which(Cell == exp.cast$Cell & Gene == exp.cast$X)])

# combind dp and dp
dc <- rbind(ffp2,ffn2)
```

```{r}
# create binomial data of df.DR
df.DR3 <- ifelse(df.DR[,-c(1)] < 0, 2,1)
df.DR3 <- as.data.frame(df.DR3)
df.DR2 <- df.DR3[, colSums(df.DR3) != 15]
rownames(df.DR2) <- df.DR[,1]
df.DR2mod <- df.DR2
df.DR2mod$Subtype <- ifelse(rownames(df.DR2mod) %in% S1, 1, 2)
```


```{r}
# Prepare predictor matrix X
# subset specific columns from dataframe containg all expression levels
dx <- dcast(dc, Cell ~ Gene, value.var = 'Explevel.value', fun.aggregate = mean)
x <- dx
# Prepare outcome matrix Y
# nrow(y) must be equal to nrow(x)


```

```{r}
# divide train and test data sets
# n <- nrow(x)
# S1 <- c('K213','K214','K156','HUCCA1','RBE','D138','HUH28')
# S2 <- c('K055','K100','D068','D131','HuCCT1','SSP25','TFK1','YSCCC')
# ns1 <- length(S1)
# ns2 <- length(S2)
# train_rows1 <- sample(1:ns1, 0.5*ns1)
# train_rows2 <- sample(1:ns2, 0.5*ns2)
# 
# list.cells <- rownames(x1.2)
# loc.cells1 <- which(list.cells %in% S1[train_rows1])
# loc.cells2 <- which(list.cells %in% S2[train_rows2])
# 
# loc.train.cells <- c(loc.cells1,loc.cells2)
# 
# x.train <- as.matrix(x[loc.train.cells,])
# x.test <- as.matrix(x[-loc.train.cells,])
# 
# y.train <- y[loc.train.cells]
# y.test <- y[-loc.train.cells]
```

Random forest function
Please remove for-loop to avoid automatically generating figures.
```{r}
#xtree.train <- as.data.frame(x.train)
# random sampling genes
#xtree.train <- as.data.frame(subset(x.train, select = c(sample(colnames(x1.2),1000))))
library(tibble)
drug.list <- colnames(df.DR2mod)
for (k in 1:length(drug.list)) {
#k <- 1
drug.name <- drug.list[k]
y1 <- df.DR2mod %>% rownames_to_column('Cell') %>% select_(.dots = c('Cell',drug.name))
colnames(y1)[2] <- 'Class'
#xtree.train$Subtype <- ifelse(rownames(xtree.train) %in% S1, 1,2)
xtree.train <- as.data.frame(x[,-c(which(colnames(x) == 'Cell'))])
rownames(xtree.train) <- x[,'Cell']
xtree.train$Subtype <- y1$Class[match(rownames(xtree.train),y1$Cell)]
xtree.train$Subtype <- as.factor(xtree.train$Subtype)

library(randomForest)
output.model <- randomForest(Subtype ~.,
           data = xtree.train, ntree = 10000, 
           #mtry = 13,
           importance = FALSE,
           localImp = TRUE)

TP <- output.model$confusion[1,1]
TN <- output.model$confusion[2,2]
FP <- output.model$confusion[2,1]
FN <- output.model$confusion[1,2]

Precision <- TP/(FP+TP)
Accuracy <- (TP+FP)/(TP+FP+TN+FN)

#which.min(output.model$err.rate[,1])
#importance(output.model,type = 2)
#varImpPlot(output.model)
# x.test <- as.data.frame(x.test)
# x.test$Subtype <- ifelse(rownames(x.test) %in% S1,1,2)
# x.test$Subtype <- factor(x.test$Subtype, levels = levels(xtree.train$Subtype))
# x.test2 <- x.test
# x.test2 <- (x.test2[,which(colnames(x.test2) != 'Subtype')])

#output.pred <- predict(output.model, x.test2, type = 'response', predict.all = TRUE)

varImp.values <- importance(output.model)
varImp.values <- as.data.frame(varImp.values)
varImp.sorted <- varImp.values[order(-varImp.values$MeanDecreaseAccuracy), , drop = FALSE]
varImp.sorted$Gene <- rownames(varImp.sorted)
#varImpPlot(output.model)

#```

#```{r}
df <- varImp.sorted %>% top_n(n = 10, wt = MeanDecreaseGini) 
top.genes.RF <- df$Gene
dt <- df %>% select_(.dots = c('Gene','MeanDecreaseAccuracy','MeanDecreaseGini'))

dt$Drug <- rep(drug.name, nrow(dt))

if (drug.name == 'Subtype'){
  list.GeneHM <- df.input %>% subset(Cell == paste(drug.name,'_1.2',sep = ''))
} else {
  list.GeneHM <- df.input %>% subset(Cell == paste(drug.name,'_S.R',sep = ''))
}

cn <- lapply(1:nrow(list.GeneHM), function(i) {
  gnls <- list.GeneHM$core_enrichment[i]
  # extract gene name using '/'
  n <- strsplit(gnls, "/")
  dn <- do.call(cbind,n)
  dh <- data.frame('Gene' = dn,
                   'Hallmark' = rep(list.GeneHM$ID[i],length(dn)),
                   'HM.category' = rep(list.GeneHM$HM.category[i], length(dn)),
                   'HM.cat.color' = rep(list.GeneHM$HM.color[i], length(dn)))
})

di <- do.call(rbind,cn)
di$HM.status <- list.GeneHM$HM.status[match(di$Hallmark, list.GeneHM$ID)]

HM.name <- lapply(1:nrow(dt), function(i) paste(as.character(di$Hallmark[which(dt$Gene[i] == di$Gene)]), collapse = ','))

dt$Hallmark <- HM.name

HM.cat <- lapply(1:nrow(dt), function(i) paste(as.character(di$HM.category[which(dt$Gene[i] == di$Gene)]), collapse = ','))

dt$HM.category <- HM.cat

HM.color <- lapply(1:nrow(dt), function(i) paste(as.character(di$HM.cat.color[which(dt$Gene[i] == di$Gene)]), collapse = ','))

dt$HM.color <- HM.color

dtexp <- xtree.train %>% select_(.dots = dt$Gene)
dtexp$Cell <- rownames(dtexp)

dtexp.m <- melt(dtexp, id.vars = 'Cell', variable.name = 'Gene', value.name = 'Explevel')
dtexp.m$MeanDecreaseGini <- dt$MeanDecreaseGini[match(dtexp.m$Gene,dt$Gene)]
dtexp.m$Subtype <- ifelse(dtexp.m$Cell %in% S1, 'S1', 'S2')
dtexp.m$Subtype <- as.factor(dtexp.m$Subtype)

#```

#```{r}
library(ggplot2)
dat.main1 <- dtexp.m %>% subset(Subtype == 'S1') %>% mutate(Order.Cell = factor(Cell, levels = S1),
                                                            Order.Gene = factor(Gene, levels = top.genes.RF))
pmain1 <- ggplot(data = dat.main1, 
                aes(x = Order.Cell,
                    #y = reorder(Gene,MeanDecreaseGini),
                    y = reorder(Order.Gene, MeanDecreaseGini))) +
  geom_tile(aes(fill = Explevel)) +
  scale_fill_gradient2(low = '#053061',
                       midpoint = 0,
                       mid = 'white',
                       high = '#67001f',
                       space = 'Lab',
                       breaks = c(-6,-3,0,3,6),
                       limits = c(-6,6),
                       oob = scales::squish,
                       na.value = 'black') +
  theme_bw() +
  theme(
    legend.position = 'left',
    axis.text.x = element_text(angle = 90, size = 7, hjust = 1, vjust = 1),
    axis.text.y = element_text(angle = 0, size = 7, hjust = 1, vjust = 0.5),
    plot.margin = unit(c(0,0.5,0,-0.5), 'cm')) +
  guides(fill = FALSE) + #guide_colorbar(barwidth = 0.5)) #, barheight = 10))
  labs(y = 'Gene',
       x = 'Subtype 1',
       fill = 'Exp.lv')

dat.main2 <- dtexp.m %>% subset(Subtype == 'S2') %>% mutate(Order.Cell = factor(Cell, levels = S2),
                                                            Order.Gene = factor(Gene, levels = top.genes.RF))
pmain2 <- ggplot(data = dat.main2, 
                aes(x = Order.Cell, y = reorder(Order.Gene,MeanDecreaseGini))) + 
  geom_tile(aes(fill = Explevel)) +
  scale_fill_gradient2(low = '#053061',
                       midpoint = 0,
                       mid = 'white',
                       high = '#67001f',
                       space = 'Lab',
                       breaks = c(-6,-3,0,3,6),
                       limits = c(-6,6),
                       oob = scales::squish,
                       na.value = 'black') +
  theme_bw() +
  theme(    
        plot.margin = unit(c(0,0.5,0,-0.5), 'cm'), 
        legend.position = 'none',
        axis.text.x = element_text(angle = 90, size = 7, hjust = 1, vjust = 1),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank()) +
  labs(x = 'Subtype 2')

xdot <- ggplot() + 
  geom_point(
    data = dt,
    aes(x = MeanDecreaseGini, y = reorder(Gene, MeanDecreaseGini))) +
  labs(x = 'MeanDecreaseGini', 
       y = NULL) + 
  annotate(label = sprintf('Precision = %.2f', Precision), geom = 'text', x = mean(range(dt$MeanDecreaseGini)), y = 1.5, size = 2) +
  annotate(label = sprintf('Accuracy = %.2f', Accuracy), geom = 'text', x = mean(range(dt$MeanDecreaseGini)), y = 2.5, size = 2) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 90, size = 7, vjust = 0.5),
    axis.line = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    plot.margin = unit(c(0,1,0,-0.5), 'cm'))

library(cowplot)
p <- plot_grid(pmain1,pmain2, xdot, nrow = 1, ncol = 3, align = 'h', 
                  rel_widths = c(1.2,1,1))

# now add the title
title <- ggdraw() + 
  draw_label(paste('Candidate Genes for ', drug.name, sep = ''),
             fontface = 'bold')
p.out <- plot_grid(title, p, ncol = 1, rel_heights = c(0.1, 1)) # rel_heights values control title
#```

#```{r}
setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq/CandidateGeneforDrugs')
strfilename = paste0('Candidate_Genes_for_RF_',drug.name,'.tiff', collapse = NULL)
tiff(filename = strfilename,  width = 1280, height = 640, units = "px", res = 200, compression = "lzw")
print(plot(p.out))
dev.off()

}
```

PLSR prediction model

```{r}
## VIP returns all VIP values for all variables and all number of components,
## as a ncomp x nvars matrix.
VIP <- function(object) {
  if (object$method != "oscorespls")
    stop("Only implemented for orthogonal scores algorithm.  Refit with 'method = \"oscorespls\"'")
  if (nrow(object$Yloadings) > 1)
    stop("Only implemented for single-response models")
  
  SS <- c(object$Yloadings)^2 * colSums(object$scores^2)
  Wnorm2 <- colSums(object$loading.weights^2)
  SSW <- sweep(object$loading.weights^2, 2, SS / Wnorm2, "*")
  sqrt(nrow(SSW) * apply(SSW, 1, cumsum) / cumsum(SS))
}


## VIPjh returns the VIP of variable j with h components
VIPjh <- function(object, j, h) {
  if (object$method != "oscorespls")
    stop("Only implemented for orthogonal scores algorithm.  Refit with 'method = \"oscorespls\"'")
  if (nrow(object$Yloadings) > 1)
    stop("Only implemented for single-response models")
  
  b <- c(object$Yloadings)[1:h]
  Ta <- object$scores[,1:h, drop = FALSE]
  SS <- b^2 * colSums(Ta^2)
  W <- object$loading.weights[,1:h, drop = FALSE]
  Wnorm2 <- colSums(W^2)
  sqrt(nrow(W) * sum(SS * W[j,]^2 / Wnorm2) / sum(SS))
}
```

```{r}
# In this section, we will calculate VIP scores by using 'orscorepls' (NIPALS) algorithm
# List of CCA cell lines used in calculation
S1 <- c('K213','K214','K156','HUCCA1','RBE','D138','HUH28')
S2 <- c('K055','D068','K100','TFK1','YSCCC','HuCCT1','D131','SSP25')
S.all <- c(S1,S2)
CCA <- S.all

# First, we have to prepare X input data frame
library(reshape2)
# drug response are in discretized scale
# df.DRmod <- df.DR
# df.DRmod$Subtype <- ifelse(df.DRmod$X %in% S1, 1, 2)
# rownames(df.DRmod) <- df.DRmod$X
# df.DRmod.x <- df.DRmod[,-c(1)]

x2 <- melt(x, id.vars = 'Cell', variable.name = 'Gene', value.name = 'Explevel')
x3 <- dcast(x2, Cell ~ Gene, value.var = 'Explevel')
rownames(x3) <- x3$Cell
x4 <- x3[,-c(1)]
Input.pathway <- x4

Input.drug <- df.DR2mod
#```{r}
# CCA subtype 1
# obtain number of pathways
num.pathway <- ncol(Input.pathway)
# obtain number of drugs
num.drug <- ncol(Input.drug)
#```

#```{r}
# CCA subtype 1
# Use this function to find predicted values using PLSR model
library(pls)
vip.drug <- lapply(1:num.drug, function(n) {
  # define independent variable
  X <- Input.pathway
  # define dependent 
  Y <- as.data.frame(Input.drug[n])
  newdat <- cbind(Y, GE = I(as.matrix(X))[match(rownames(Y), rownames(X)), drops = TRUE])  # this line is to create data input for pls package***
  num.prcomp <- nrow(newdat)
  colnames(newdat)[1] <- 'Drug'
  myplsr <- plsr(Drug ~ GE, num.prcomp-1, data = newdat, 
                 method = 'oscorespls',
                 scale = FALSE,
                 validation = 'LOO')
  # calculate VIP score of variable (pathway) per GR50 of the drug tested
  vip.score <- lapply(1:num.pathway, function(x) VIPjh(myplsr,x,myplsr$ncomp))
  vip.out <- as.data.frame(do.call(rbind,vip.score))
  colnames(vip.out)[1] <- colnames(Y)
  
  # calculate coef value of linear regression model based on observed and predicted variables from PC1 from PLSR
  add.sign <- lapply(1:num.pathway, function(p) {
    df2 <- data.frame('x' = newdat[,2][,p], 
                      'y' = newdat[,1])
    # create linear regression model
    df2.lm <- lm(y ~ x, data = df2)
    # extract coefficient value
    m <- df2.lm$coefficients[2]
    # determine whether coeff m is positive or negative
    value <- ifelse(m < 0, -vip.out[p,1], vip.out[p,1])
    return(value)
  })
  vip.sign <- do.call(rbind,add.sign)
  vip.sign <- as.data.frame(vip.sign)
  colnames(vip.sign)[1] <- colnames(Y)
  
  # collect R2 from PLSR model
  dat.R2 <- R2(myplsr)
  # collect Mean Squared Prediction Error from PLSR model
  dat.MSEP <- MSEP(myplsr)
  
  vip.outputs <- list('VIPtable' = vip.out,
                      'R2' = dat.R2,
                      'MSPE' = dat.MSEP,
                      'VIPsign' = vip.sign)
  return(vip.outputs)
})

# VIP score matrix without sign
temp.mat <- lapply(1:length(vip.drug), function(q) {
  VIPscore <- vip.drug[[q]]$VIPtable
})

VIP.matrix <- do.call(cbind,temp.mat)
rownames(VIP.matrix) <- colnames(Input.pathway)

# VIP score matrix with sign
temp.mat2 <- lapply(1:length(vip.drug), function(r) {
  VIPsign <- vip.drug[[r]]$VIPsign
})

VIPsign.matrix <- do.call(cbind,temp.mat2)
rownames(VIPsign.matrix) <- colnames(Input.pathway)

```

```{r}
# subset Subtype column
list.drugs <- colnames(VIP.matrix)

for (n in 1:length(list.drugs)) {
drug.name <- list.drugs[n]
library(tibble)
candidate.genes <- VIP.matrix %>% rownames_to_column('Gene') %>% select_(.dots = c('Gene',drug.name)) %>% column_to_rownames('Gene')

colnames(candidate.genes)[1] <- 'VIP.score'

# remove any rows below zero
candidate.genes2 <- candidate.genes %>% rownames_to_column('Gene') %>% 
  filter(VIP.score > 1) %>% arrange(desc(as.numeric(VIP.score))) %>%
  column_to_rownames('Gene')
candidate.genes2$Gene <- rownames(candidate.genes2)

dvexp <- xtree.train %>% select_(.dots = rownames(candidate.genes2))
dvexp$Cell <- rownames(dvexp)

dvexp.m <- melt(dvexp, id.vars = 'Cell', variable.name = 'Gene', value.name = 'Explevel')
dvexp.m$VIP.score <- candidate.genes2$VIP.score[match(dvexp.m$Gene,candidate.genes2$Gene)]
dvexp.m$Subtype <- ifelse(dvexp.m$Cell %in% S1, 'S1', 'S2')
dvexp.m$Subtype <- as.factor(dvexp.m$Subtype)
#```

cc <- rev(c('#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#ffffff','#d1e5f0','#92c5de','#4393c3','#2166ac','#053061'))
#```{r}
top.genes <- candidate.genes2 %>% top_n(n = 10, wt = VIP.score)
dv.main1 <- dvexp.m %>% subset(Subtype == 'S1' & Gene %in% top.genes$Gene) %>% mutate(Order.Cell = factor(Cell, levels = S1))
vipmain1 <- ggplot(data = dv.main1, 
                aes(x = Order.Cell, y = reorder(Gene,VIP.score))) + 
  # geom_tile(aes(fill = cut(Explevel, breaks = c(0:11), labels = c(-5:5)))) +
  # scale_fill_manual(values = cc, drop = FALSE, na.value = '#F0F0F0') +
  geom_tile(aes(fill = Explevel)) +
  scale_fill_gradient2(low = '#053061',
                       midpoint = 0,
                       mid = 'white',
                       high = '#67001f',
                       space = 'Lab',
                       breaks = c(-6,-3,0,3,6),
                       limits = c(-6,6),
                       oob = scales::squish,
                       na.value = 'black') +
  theme_bw() +
  theme(
    legend.position = 'left',
    axis.text.x = element_text(angle = 90, size = 7, hjust = 1, vjust = 1),
    axis.text.y = element_text(angle = 0, size = 7, hjust = 1, vjust = 0.5),
    plot.margin = unit(c(0,0.5,0,-0.5), 'cm')) +
  guides(fill = FALSE) + #guide_colorbar(barwidth = 0.5)) #, barheight = 10))
  labs(y = 'Gene',
       x = 'Subtype 1',
       fill = 'Exp.lv')

dv.main2 <- dvexp.m %>% subset(Subtype == 'S2' & Gene %in% top.genes$Gene) %>% mutate(Order.Cell = factor(Cell, levels = S2))
vipmain2 <- ggplot(data = dv.main2, 
                aes(x = Order.Cell, y = reorder(Gene,VIP.score))) + 
  # geom_tile(aes(fill = cut(Explevel, breaks = c(0:11), labels = c(-5:5)))) +
  # scale_fill_manual(values = cc, drop = FALSE, na.value = '#F0F0F0') +
  geom_tile(aes(fill = Explevel)) +
  scale_fill_gradient2(low = '#053061',
                       midpoint = 0,
                       mid = 'white',
                       high = '#67001f',
                       space = 'Lab',
                       breaks = c(-6,-3,0,3,6),
                       limits = c(-6,6),
                       oob = scales::squish,
                       na.value = 'black') +
  theme_bw() +
  theme(    
        plot.margin = unit(c(0,0.5,0,-0.5), 'cm'), 
        legend.position = 'none',
        axis.text.x = element_text(angle = 90, size = 7, hjust = 1, vjust = 1),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank()) +
  labs(x = 'Subtype 2')

vipdot <- ggplot() + 
  geom_point(
    data = top.genes,
    aes(x = VIP.score, y = reorder(Gene, VIP.score))) +
  labs(x = 'VIP score', 
       y = NULL) + 
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 90, size = 7, vjust = 0.5),
    axis.line = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    plot.margin = unit(c(0,1,0,-0.5), 'cm'))

vp <- plot_grid(vipmain1,vipmain2, vipdot, nrow = 1, ncol = 3, align = 'h', 
                  rel_widths = c(1.2,1,1))

# now add the title
title <- ggdraw() + 
  draw_label(paste('Candidate Genes for ', drug.name, sep = ''),
             fontface = 'bold')
vp.out <- plot_grid(title, vp, ncol = 1, rel_heights = c(0.1, 1)) # rel_heights values control title margins

setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq/CandidateGeneforDrugsVIP')
strfilename = paste0('Candidate_Genes_for_VIP_',drug.name,'.tiff', collapse = NULL)
tiff(filename = strfilename,  width = 1280, height = 640, units = "px", res = 200, compression = "lzw")
print(plot(vp.out))
dev.off()
}
```


PLS-RF
```{r}
#xtree.train <- as.data.frame(x.train)
# random sampling genes
#xtree.train <- as.data.frame(subset(x.train, select = c(sample(colnames(x1.2),1000))))
library(tibble)
drug.list <- colnames(df.DR2mod)
for (k in 1:length(drug.list)) {
#k <- 1
drug.name <- drug.list[k]
y1 <- df.DR2mod %>% rownames_to_column('Cell') %>% select_(.dots = c('Cell',drug.name))
colnames(y1)[2] <- 'Class'
#xtree.train$Subtype <- ifelse(rownames(xtree.train) %in% S1, 1,2)
xtree.train <- as.data.frame(x[,-c(which(colnames(x) == 'Cell'))])
rownames(xtree.train) <- x$Cell
list.genes <- rownames(VIP.matrix)[VIP.matrix[,drug.name] > 1]
xtree.train.dr <- xtree.train %>% select_(.dots = c(list.genes))
rownames(xtree.train.dr) <- rownames(xtree.train)
xtree.train.dr$Subtype <- y1$Class[match(rownames(xtree.train.dr),y1$Cell)]
xtree.train.dr$Subtype <- as.factor(xtree.train.dr$Subtype)

library(randomForest)
output.model <- randomForest(Subtype ~.,
           data = xtree.train.dr, ntree = 10000, 
           #mtry = 13,
           importance = FALSE,
           localImp = TRUE)

TP <- output.model$confusion[1,1]
TN <- output.model$confusion[2,2]
FP <- output.model$confusion[2,1]
FN <- output.model$confusion[1,2]

Precision <- TP/(FP+TP)
Accuracy <- (TP+FP)/(TP+FP+TN+FN)

#which.min(output.model$err.rate[,1])
#importance(output.model,type = 2)
#varImpPlot(output.model)
# x.test <- as.data.frame(x.test)
# x.test$Subtype <- ifelse(rownames(x.test) %in% S1,1,2)
# x.test$Subtype <- factor(x.test$Subtype, levels = levels(xtree.train$Subtype))
# x.test2 <- x.test
# x.test2 <- (x.test2[,which(colnames(x.test2) != 'Subtype')])

#output.pred <- predict(output.model, x.test2, type = 'response', predict.all = TRUE)

varImp.values <- importance(output.model)
varImp.values <- as.data.frame(varImp.values)
varImp.sorted <- varImp.values[order(-varImp.values$MeanDecreaseAccuracy), , drop = FALSE]
varImp.sorted$Gene <- rownames(varImp.sorted)
#varImpPlot(output.model)

#```

#```{r}
df <- varImp.sorted %>% top_n(n = 10, wt = MeanDecreaseGini) 
top.genes.RF <- df$Gene
dt <- df %>% select_(.dots = c('Gene','MeanDecreaseAccuracy','MeanDecreaseGini'))

dt$Drug <- rep(drug.name, nrow(dt))

if (drug.name == 'Subtype'){
  list.GeneHM <- df.input %>% subset(Cell == paste(drug.name,'_1.2',sep = ''))
} else {
  list.GeneHM <- df.input %>% subset(Cell == paste(drug.name,'_S.R',sep = ''))
}

cn <- lapply(1:nrow(list.GeneHM), function(i) {
  gnls <- list.GeneHM$core_enrichment[i]
  # extract gene name using '/'
  n <- strsplit(gnls, "/")
  dn <- do.call(cbind,n)
  dh <- data.frame('Gene' = dn,
                   'Hallmark' = rep(list.GeneHM$ID[i],length(dn)),
                   'HM.category' = rep(list.GeneHM$HM.category[i], length(dn)),
                   'HM.cat.color' = rep(list.GeneHM$HM.color[i], length(dn)))
})

di <- do.call(rbind,cn)
di$HM.status <- list.GeneHM$HM.status[match(di$Hallmark, list.GeneHM$ID)]

HM.name <- lapply(1:nrow(dt), function(i) paste(as.character(di$Hallmark[which(dt$Gene[i] == di$Gene)]), collapse = ','))

dt$Hallmark <- HM.name

HM.cat <- lapply(1:nrow(dt), function(i) paste(as.character(di$HM.category[which(dt$Gene[i] == di$Gene)]), collapse = ','))

dt$HM.category <- HM.cat

HM.color <- lapply(1:nrow(dt), function(i) paste(as.character(di$HM.cat.color[which(dt$Gene[i] == di$Gene)]), collapse = ','))

dt$HM.color <- HM.color

dtexp <- xtree.train %>% select_(.dots = dt$Gene)
dtexp$Cell <- rownames(dtexp)

dtexp.m <- melt(dtexp, id.vars = 'Cell', variable.name = 'Gene', value.name = 'Explevel')
dtexp.m$MeanDecreaseGini <- dt$MeanDecreaseGini[match(dtexp.m$Gene,dt$Gene)]
dtexp.m$Subtype <- ifelse(dtexp.m$Cell %in% S1, 'S1', 'S2')
dtexp.m$Subtype <- as.factor(dtexp.m$Subtype)

#```

#```{r}
library(ggplot2)
dat.main1 <- dtexp.m %>% subset(Subtype == 'S1') %>% mutate(Order.Cell = factor(Cell, levels = S1),
                                                            Order.Gene = factor(Gene, levels = top.genes.RF))
pmain1 <- ggplot(data = dat.main1, 
                aes(x = Order.Cell,
                    #y = reorder(Gene,MeanDecreaseGini),
                    y = reorder(Order.Gene, MeanDecreaseGini))) +
  geom_tile(aes(fill = Explevel)) +
  scale_fill_gradient2(low = '#053061',
                       midpoint = 0,
                       mid = 'white',
                       high = '#67001f',
                       space = 'Lab',
                       breaks = c(-6,-3,0,3,6),
                       limits = c(-6,6),
                       oob = scales::squish,
                       na.value = 'black') +
  theme_bw() +
  theme(
    legend.position = 'left',
    axis.text.x = element_text(angle = 90, size = 7, hjust = 1, vjust = 1),
    axis.text.y = element_text(angle = 0, size = 7, hjust = 1, vjust = 0.5),
    plot.margin = unit(c(0,0.5,0,-0.5), 'cm')) +
  guides(fill = FALSE) + #guide_colorbar(barwidth = 0.5)) #, barheight = 10))
  labs(y = 'Gene',
       x = 'Subtype 1',
       fill = 'Exp.lv')

dat.main2 <- dtexp.m %>% subset(Subtype == 'S2') %>% mutate(Order.Cell = factor(Cell, levels = S2),
                                                            Order.Gene = factor(Gene, levels = top.genes.RF))
pmain2 <- ggplot(data = dat.main2, 
                aes(x = Order.Cell, y = reorder(Order.Gene,MeanDecreaseGini))) + 
  geom_tile(aes(fill = Explevel)) +
  scale_fill_gradient2(low = '#053061',
                       midpoint = 0,
                       mid = 'white',
                       high = '#67001f',
                       space = 'Lab',
                       breaks = c(-6,-3,0,3,6),
                       limits = c(-6,6),
                       oob = scales::squish,
                       na.value = 'black') +
  theme_bw() +
  theme(#plot.margin = margin(5.5, 5.5, 5.5, 5.5),
    plot.margin = unit(c(0,0.5,0,-0.5), 'cm'), 
    legend.position = 'none',
    axis.text.x = element_text(angle = 90, size = 7, hjust = 1, vjust = 1),
    axis.text.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()) +
  labs(x = 'Subtype 2')

xdot <- ggplot() + 
  geom_point(
    data = dt,
    aes(x = MeanDecreaseGini, y = reorder(Gene, MeanDecreaseGini))) +
  labs(x = 'MeanDecreaseGini', 
       y = NULL) + 
  annotate(label = sprintf('Precision = %.2f', Precision), geom = 'text', x = mean(range(dt$MeanDecreaseGini)), y = 1.5, size = 2) +
  annotate(label = sprintf('Accuracy = %.2f', Accuracy), geom = 'text', x = mean(range(dt$MeanDecreaseGini)), y = 2.5, size = 2) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 90, size = 7, vjust = 0.5),
    axis.line = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    #plot.margin = margin(5.5, 5.5, 5.5, 5.5),
    plot.margin = unit(c(0,1,0,-0.5), 'cm'))

library(cowplot)
p <- plot_grid(pmain1,pmain2, xdot, nrow = 1, ncol = 3, align = 'h', 
                  rel_widths = c(1.2,1,1))

# now add the title
title <- ggdraw() + 
  draw_label(paste('Candidate Genes for ', drug.name, sep = ''),
             fontface = 'bold')
p.out <- plot_grid(title, p, ncol = 1, rel_heights = c(0.1, 1)) # rel_heights values control title margins
#```

#```{r}
setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq/CandidateGeneforDrugsVIPRF')
strfilename = paste0('Candidate_Genes_for_VIPRF10_',drug.name,'.tiff', collapse = NULL)
tiff(filename = strfilename,  width = 1280, height = 640, units = "px", res = 200, compression = "lzw")
print(plot(p.out))
dev.off()

}
```









```{r}
library(pheatmap)

dvmat <- dvexp.m %>% dcast(Gene ~ Cell, value.var = c('Explevel')) %>% column_to_rownames('Gene') %>% as.matrix()
# remove rows with zero
row_sub = apply(dvmat, 1, function(row) all(row !=0 ))
##Subset as usual
dvmat2 <- dvmat[row_sub,]

cc <- cc <- rev(RColorBrewer::brewer.pal(7,'RdBu'))

ct_hp2 <- pheatmap(dvmat , 
                  scale = 'row',       # 'row' 'column' 'none'
                  cluster_rows = TRUE,                    # boolean for cluster by rows
                  cluster_cols = TRUE,                 # boolean for cluster by columns
                  clustering_method = 'ward.D2',          # method for clustering
                  clustering_distance_rows = 'euclidean', # use euclidean distance
                  clustering_distance_cols = 'euclidean', # use euclidean distance
                  #cellwidth = 8,                         # set cell width
                  #cellheight = 12,                       # set cell height
                  #treeheight_row = 10,
                  #treeheight_col = 5,
                  #cutree_rows = 3,                        # set break gap between rows
                  #cutree_cols = 5,                        # set break gap between columns
                  show_colnames = TRUE,                   # boolean for showing column names
                  show_rownames = TRUE,                   # boolean for showing row names
                  #annotation = dat.anno,
                  #main = 'VIP scores of Subtype 1',
                  #fontsize = 7,
                  color = cc)
```








Elastic net function

```{r}
# # Fit models:
# fit.lasso <- glmnet(x.train, y.train, family = 'gaussian', alpha = 1)
# fit.ridge <- glmnet(x.train, y.train, family = 'gaussian', alpha = 0)
# fit.elnet <- glmnet(x.train, y.train, family = 'gaussian', alpha = .5)
# 
# 
# # 10-fold Cross validation for each alpha = 0, 0.1, ... , 0.9, 1.0
# fit.lasso.cv <- cv.glmnet(x.train, y.train, type.measure = 'mse', alpha = 1, 
#                           family = 'gaussian')
# fit.ridge.cv <- cv.glmnet(x.train, y.train, type.measure = 'mse', alpha = 0,
#                           family = 'gaussian')
# fit.elnet.cv <- cv.glmnet(x.train, y.train, type.measure = 'mse', alpha = .5,
#                           family = 'gaussian')

# run 10-fold cross validation using for loop
for (i in 0:10) {
    assign(paste('fit', i, sep = ""), cv.glmnet(x.train, y.train, type.measure = 'mse', 
                                              alpha = i/10,
                                              family = 'binomial'))
}

```

```{r}
# # Plot solution paths:
# par(mfrow = c(3,2))
# # For plotting options, type '?plot.glmnet' in R console
# plot(fit.lasso, xvar = 'lambda')
# plot(fit10, main = 'LASSO')
# 
# plot(fit.ridge, xvar = 'lambda')
# plot(fit0, main = 'Ridge')

#plot(fit5, xvar = 'lambda')
plot(fit5, main = 'Elastic Net')
```

```{r}
yhat0 <- predict(fit0, s = fit0$lambda.1se, newx = x.test)
yhat1 <- predict(fit1, s = fit1$lambda.1se, newx = x.test)
yhat2 <- predict(fit2, s = fit2$lambda.1se, newx = x.test)
yhat3 <- predict(fit3, s = fit3$lambda.1se, newx = x.test)
yhat4 <- predict(fit4, s = fit4$lambda.1se, newx = x.test)
yhat5 <- predict(fit5, s = fit5$lambda.1se, newx = x.test)
yhat6 <- predict(fit6, s = fit6$lambda.1se, newx = x.test)
yhat7 <- predict(fit7, s = fit7$lambda.1se, newx = x.test)
yhat8 <- predict(fit8, s = fit8$lambda.1se, newx = x.test)
yhat9 <- predict(fit9, s = fit9$lambda.1se, newx = x.test)
yhat10 <- predict(fit10, s = fit10$lambda.1se, newx = x.test)

mse0 <- mean((y.test - yhat0)^2)
mse1 <- mean((y.test - yhat1)^2)
mse2 <- mean((y.test - yhat2)^2)
mse3 <- mean((y.test - yhat3)^2)
mse4 <- mean((y.test - yhat4)^2)
mse5 <- mean((y.test - yhat5)^2)
mse6 <- mean((y.test - yhat6)^2)
mse7 <- mean((y.test - yhat7)^2)
mse8 <- mean((y.test - yhat8)^2)
mse9 <- mean((y.test - yhat9)^2)
mse10 <- mean((y.test - yhat10)^2)
```

```{r}
list.coef <- coef(fit5, s = 'lambda.min')

colSums(list.coef == 0)
```


```{r}
#get test data
#predict class, type=”class”
lasso_prob <- predict(fit5, newx = x.test, s = 'lambda.1se', type = 'response')

```

The fine-tuning of the penalization factor of Elastic Net during the cross validation has resulted in a penalty that shrinks all coefficients to zero.

Without being mathematically exact this seems to indicates that none of your features is very helpful. In this case Elastic Net will always predict the mean of the data it was trained on.

```{r}
# 3. Hierarchical clustering
# combine dataframe of positive and negative NES
dc <- rbind(dp,dn)
dh <- dcast(dc, Hallmark ~ Gene, value.var = 'Explevel.value')
# impute NAs to zeros
dh[is.na(dh)] <- 0

cc <- rev(RColorBrewer::brewer.pal(7,'RdBu'))

library(pheatmap)
ct_hp2 <- pheatmap(dh[,-c(1)], 
                  scale = 'column',       # 'row' 'column' 'none'
                  cluster_rows = FALSE,                    # boolean for cluster by rows
                  cluster_cols = TRUE,                    # boolean for cluster by columns
                  clustering_method = 'ward.D2',          # method for clustering
                  clustering_distance_rows = 'euclidean', # use euclidean distance
                  clustering_distance_cols = 'euclidean', # use euclidean distance
                  cellwidth = 1.5,                         # set cell width
                  cellheight = 10,                       # set cell height
                  #treeheight_row = 10,
                  #treeheight_col = 10,
                  #cutree_rows = 4,                        # set break gap between rows
                  #cutree_cols = 5,                        # set break gap between columns
                  #show_colnames = TRUE,                   # boolean for showing column names
                  #show_rownames = TRUE,                   # boolean for showing row names
                  #annotation = dat.anno,
                  #main = 'VIP scores of Subtype 2',
                  fontsize = 5,
                  color = cc)
```

















```{r}
library(reshape2)
e <- dcast(dp, Hallmark ~ Gene, value.var = 'NES.value')
e[is.na(e)] <- 0

# get frequency of genes
freq <- colSums(e[,-c(1)])
names(freq) <- colnames(e[,-c(1)])

el <- e[,-c(1)]
fel <- el[, order(freq, decreasing = TRUE)]
f <- cbind('Hallmark' = e$Hallmark,fel)
mf <- melt(f, id.vars = 'Hallmark',
           variable.name = 'Gene',
           value.name = 'value')

mf$GeneOrder <- freq[match(mf$Gene,names(freq))]
```


```{r}
library(ggplot2)
fig1 <- ggplot(mf, aes(x = reorder(Gene, -GeneOrder), 
               y = Hallmark)) +
  geom_tile(aes(fill = value)) +
  theme(
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank()
  )

```

