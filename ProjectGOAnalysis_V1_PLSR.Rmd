---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(dplyr)
library(tidyr)
```

```{r}
# This part will emphasize on calculating VIP scores
# load CCA's drug response data 
setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq')
Sig <- read.csv('Matrix_for_raster_plots.csv', header = TRUE, stringsAsFactors = FALSE)
drugResponses <- read.csv('GR50_87drug.csv', header = TRUE, stringsAsFactors = FALSE)
```


```{r}
# We will build a prediction model using NES scores of hallmarks and drug responses
# First, we will subset data using CCA cell names
# Create a list of CCA names with cell names in subtype 1 and subtype 2
S1 <- c('K213','K214','K156','HUCCA1','RBE','D138')
S2 <- c('HuCCT1','TYBDC1','K055','D068','D131','TFK1','K100','YSCCC','SSP25')
# Subset only CCA subtype 1
selSig <- Sig %>% filter(Cell %in% S1)
# Transfrom long table to wide table using reshape2 package
library(reshape2)
mx.by.subtypes <- dcast(selSig, ID ~ factor(Cell), value.var = 'NES')

# We found that each CCA subtype has different pattern of drug responses
# Therefore, we need different drug prediction model for each CCA subtype
# Now, we will select multiple columns whose colnames are in S1
mx2.filter <- mx.by.subtypes %>% select_(.dots = c(S1))
# replace NAs with zeros
mx2.filter[is.na(mx2.filter)] <- 0
# Add hallmarks from previous data frame as rownames to the current matrix
rownames(mx2.filter) <- mx.by.subtypes$ID
# Assign to new matrix for next step
mxx2 <- mx2.filter
# count number of zero per row and remove the rows of zero number is larger than 80% of cell lines
#mxx2 <- mx2.filter[rowSums(mx2.filter == 0) <= (ncol(mx2.filter)-floor(ncol(mx2.filter)*0.5)), ]

```


```{r}
# Prepare drug response data frame
# transpose to long table
colnames(drugResponses)[1] <- 'Cell'
rownames(drugResponses) <- drugResponses$Cell
drmx <- drugResponses[,-1] # matrix of drug response for all breast cancer cell lines
```


```{r}
# We will prepare Hallmarks data frame for X input in PLSR
tmx <- t(mxx2)
Train.pmx <- as.data.frame(tmx)
# We will prepare Drug response data frame for Y input in PLSR
Train.drmx <- drmx %>% subset(row.names(drmx) %in% S1)
```

```{r}
# follow analytical steps per instruction manual
# Assign Pathway data frame as X input 
X <- Train.pmx
# Assign Drug Response data frame as Y input
Y <- Train.drmx %>% select('Erlotinib')
# This line is to create data input for ***pls package***
newdat <- cbind(Y, GE = I(as.matrix(X))[match(rownames(Y), rownames(X)), drops = TRUE]) # drops = TRUE to retain all attributes. Otherwise, it will cause error when running plsr model.

# Define number of principle component (n-1)
num.prcomp <- nrow(X) - 1
```

```{r}
library(pls)
myplsr <- plsr(Erlotinib ~ GE, num.prcomp, data = newdat, 
               method = 'oscorespls',
               validation = 'LOO')

# look at R2 graph to determine appropriate number of components
#plot(R2(myplsr))
```


```{r}
# After generating a PLSR model, we will determine the best component (fittest) from fold-change of CV from RMSEP
# METHOD 1
# In this test, diff comp > 10 is ignored
# Create a function to find best component
findPLSRcomp <- function(myplsr) {
  # Recall library(pls) and use built-in function to obtain Root Mean Squared Error of Prediction (RMSEP)
  a <- RMSEP(myplsr)
  # Create a data frame displaying CV
  df.cv <- as.data.frame(a$val)
  # Determine number of Componts. (Exclude First column)
  n <- length(df.cv[2,]) - 1
  # Calculate difference between Component(n)'s CV and Component(n+1)'s CV
  fc.out <- lapply(1:n, function(n) {
    df.cv[2,n+2] / df.cv[2,n+1]
  })
  # Put Diff CVs into a data frame
  fc.table <- as.data.frame(do.call(rbind,fc.out))
  # Find which row having CV difference greater than 10
  comp <- which(fc.table$V1 > 10)
  if (length(comp) == 0){
    sel.comp <- 0
  } else if (comp == 0) {
    # Choose the row (Component) before that
    sel.comp <- 0
  } else {
    sel.comp <- comp - 1
  }
  return(sel.comp)
}

bestcomp <- findPLSRcomp(myplsr)
```

```{r}
# METHOD 2
# Use built-in function in pls package
selNcomp.Onesigma <- selectNcomp(myplsr, 'onesigma', plot = FALSE)
selNcomp.Random <- selectNcomp(myplsr, 'randomization', plot = FALSE)
```

```{r}
myplsr2 <- plsr(Erlotinib ~ GE, 4, data = newdat, 
               method = 'oscorespls',
               validation = 'LOO')

# use observed and predicted data from PC1
df2 <- data.frame('observed' = myplsr2$model[,1], 
                  'predicted' = myplsr2$fitted.values[,,1], 
                  'residuals' = myplsr2$residuals[,,1])
# create linear regression model
df2.lm <- lm(predicted ~ observed, data = df2)
# extract coefficient value
m <- df2.lm$coefficients[2]
# determine whether coeff m is positive or negative
m.sign <- ifelse(m < 0, 'negative', 'positive')

# calculate PRESS
library(qpcR)
Press <- PRESS(df2.lm)

# calculate TSS
Tss <- sum((df2$observed - mean(df2$observed))^2)

Q2 <- 1 - (Press$P.square/Tss)

# extract R2 from lm
R2 <- summary(df2.lm)$adj.r.squared 
```


```{r}
# plot prediction accuracy of plsr model
library(ggpmisc)
sp1 <- ggplot(df2, aes(x = observed, y = predicted)) +
  geom_point() +
  geom_smooth(method = lm, formula = y ~ x, se = FALSE) + 
  # stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
  #              label.x.npc = "right", label.y.npc = 0.15,
  #              formula = y ~ x, parse = TRUE, size = 3) +
  
  coord_fixed(ratio = 1,xlim = c(floor(min(df2$observed,df2$predicted)),
                 ceiling(max(df2$observed,df2$predicted))),
                 ylim = c(floor(min(df2$observed,df2$predicted)), ceiling(max(df2$observed,df2$predicted)))) +
  # coord_equal() +
  theme_bw() +
  labs(x = 'Observed GR50',
       y = 'Predicted GR50',
       title = '')

library(grid)
# Create a text
grob <- grobTree(textGrob(paste0('R2 = ',format(round(R2,2),nsmall = 2),
                                 '\nQ2 = ',
                                 format(round(Q2,2),nsmall = 2)),
                          x = 0.1,  
                          y = 0.90, 
                          hjust = 0,
                          gp = gpar(col = 'black', 
                                    fontsize = 10, 
                                    fontface = 'italic')))

sp1 + annotation_custom(grob)
```


```{r}
# use PC score for ploting
scoredat <- data.frame('PC1' = myplsr2$scores[,1], # from component1
                       'PC2' = myplsr2$scores[,2], # from component2
                       'Cell' = S1,
                       'Drug' = drmx %>% filter(rownames(drmx) %in% S1) %>% select_('Erlotinib'))

subtype <- lapply(1:nrow(scoredat), function(x) {
  cellstr <- scoredat$Cell[x] #gsub('\\_.*','',new_scores$Cell[x])
  if (cellstr %in% S1){
    Type <- 'S1'
  } else if (cellstr %in% S2){
    Type <- 'S2'
  }})
#plot(myplsr2$scores[,2], myplsr2$scores[,5])

scoredat <- as.data.frame(append(scoredat,data.frame('subtype' = do.call(rbind,subtype))))

library(ggrepel)

ct_plsr <- ggplot(scoredat, aes(x = PC1, 
                   y = PC2)) +
  #geom_hline(yintercept = 0, colour = 'gray65') +
  #geom_vline(xintercept = 0, colour = 'gray65') +
  geom_point(aes(color = Erlotinib, shape = factor(subtype)), size = 5) +
  #scale_size(breaks = c(-8,-6,-4,-2,0), labels = c(8,6,4,2,0)) +
  scale_color_gradient(low = 'blue', high = 'red') +
  geom_text_repel(aes(label = Cell), 
                  size = 3, 
                  alpha = 0.75,
                  box.padding = unit(1, 'lines'),
                  point.padding = 0.1,
                  segment.colour = 'gray60',
                  segment.size = 0.5,
                  segment.alpha = 0.5,
                  force = 2) +
  geom_hline(yintercept = 0, color = 'black', size = 1, linetype = 2) +
  geom_vline(xintercept = 0, color = 'black', size = 1, linetype = 2) +
  #guides(size = FALSE) +
  labs(x = paste0('PC1'),
       y = paste0('PC2'),
       colour = 'GR50',
       #size = 'sensitivity \n(IC50)',
       shape = 'Subtype',
       title = 'PLSR (NIPALS) of CCA subtypes \n and responses to  Erlotinib') +
  theme_bw()

ct_plsr
```
