---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(dplyr)
library(tidyr)
```

```{r}
# This part will emphasize on calculating VIP scores
# load CCA's drug response data 
setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq')
Sig <- read.csv('Matrix_for_raster_plots.csv', header = TRUE, stringsAsFactors = FALSE)
drugResponses <- read.csv('GR50_87drug.csv', header = TRUE, stringsAsFactors = FALSE)
```


```{r}
# We will build a prediction model using NES scores of hallmarks and drug responses
# First, we will subset data using CCA cell names
# Create a list of CCA names with cell names in subtype 1 and subtype 2 are rearranged in order
subtype.order <- c('K213','K214','K156','HUCCA1','RBE','D138','HuCCT1','TYBDC1','K055','D068','D131','TFK1','K100','YSCCC','SSP25')
# Subset data using dplyr
selSig <- Sig %>% filter(Cell %in% subtype.order)
# Transfrom long table to wide table using reshape2 package
mx.by.subtypes <- dcast(selSig, ID ~ factor(Cell,subtype.order), value.var = 'NES')

# We found that each CCA subtype has different pattern of drug responses
# Therefore, we need different drug prediction model for each CCA subtype
# Now, we will select multiple columns whose colnames are in S1
mx2.filter <- mx.by.subtypes %>% select_(.dots = c(S1))
# replace NAs with zeros
mx2.filter[is.na(mx2.filter)] <- 0
# Add hallmarks from previous data frame as rownames to the current matrix
rownames(mx2.filter) <- mx.by.subtypes$ID
# Assign to new matrix for next step
mxx2 <- mx2.filter
# count number of zero per row and remove the rows of zero number is larger than 80% of cell lines
#mxx2 <- mx2.filter[rowSums(mx2.filter == 0) <= (ncol(mx2.filter)-floor(ncol(mx2.filter)*0.5)), ]

```


```{r}
# transpose to long table
colnames(drugResponses)[1] <- 'Cell'
rownames(drugResponses) <- drugResponses$Cell
drmx <- drugResponses[,-1] # matrix of drug response for all breast cancer cell lines
```


```{r}
# create NES matrix of Cell x Pathway
tmx <- t(mxx2)
pmx <- as.data.frame(tmx)# NES matrix of cells x pathways
List.cells <- intersect(rownames(drmx), rownames(pmx)) # list of cell lines in the two matrices that intersect

# use the list of intersected cell lines as filter
pmxTrain <- pmx %>% filter(rownames(pmx) %in% List.cells) # %>% transpose
rownames(pmxTrain) <- List.cells

# Prepare scaled NES matrix 
# scale NES scores across cell lines
pmx2 <- t(pmxTrain)
pmx2Train <- apply(pmx2,1, scale) # scale data across rows
tpmx2 <- as.data.frame(pmx2Train)
colnames(tpmx2) <- colnames(pmxTrain)
rownames(tpmx2) <- List.cells

# Prepare drug response matrix
drmxTrain <- drmx %>% filter(rownames(drmx) %in% List.cells) # %>% transpose
rownames(drmxTrain) <- List.cells

# separate NES matrix of pathways into subtype 1 and subtype 2
S1 <- tpmx2[which(rownames(tpmx2) %in% c('K213','K214','K156','HUCCA1','RBE','D138')),]
S2 <- tpmx2[which(rownames(tpmx2) %in% c('HuCCT1','TYBDC1','K055','D068','D131','TFK1','K100','YSCCC','SSP25')),]

# separate drug response into subtype 1 and subtype 2
D1 <- drmxTrain[which(rownames(drmxTrain) %in% c('K213','K214','K156','HUCCA1','RBE','D138')),]
D2 <- drmxTrain[which(rownames(drmxTrain) %in% c('HuCCT1','TYBDC1','K055','D068','D131','TFK1','K100','YSCCC','SSP25')),]

# follow analytical steps per instruction manual
# use subtype 1
X <- S1 #pmxTrain
Y <- data.frame('DR.test' = D1$Erlotinib)
newdat <- cbind(Y, GE = I(as.matrix(X))) # this line is to create data input for pls package***
num.prcomp <- nrow(X)-1
library(pls)
myplsr <- plsr(DR.test ~ GE, num.prcomp, data = newdat, 
               method = 'oscorespls',
               validation = 'LOO')

# look at R2 graph to determine appropriate number of components
plot(R2(myplsr))
```


```{r}
# determine best component for plsr
# using fold-change of CV from RMSEP
# diff comp > 10 is ignored
findPLSRcomp <- function(myplsr) {
  a <- RMSEP(myplsr)
  df.cv <- as.data.frame(a$val)
  
  n <- length(df.cv[2,])
  fc.out <- lapply(1:n, function(n) {
    fc <- df.cv[2,n+1] / df.cv[2,n]
  })
  
  fc.table <- as.data.frame(do.call(rbind,fc.out))
  comp <- which(fc.table$V1 > 10)
  sel.comp <- comp - 1
  return(sel.comp)
}

bestcomp <- findPLSRcomp(myplsr)

myplsr <- plsr(DR.test ~ GE, bestcomp, data = newdat, 
               method = 'oscorespls',
               validation = 'LOO')

# use observed and predicted data from PC1
df2 <- data.frame('observed' = myplsr$model[,1], 
                  'predicted' = myplsr$fitted.values[,,1], 
                  'residuals' = myplsr$residuals[,,1])
# create linear regression model
df2.lm <- lm(predicted ~ observed, data = df2)
# extract coefficient value
m <- df2.lm$coefficients[2]
# determine whether coeff m is positive or negative
m.sign <- ifelse(m < 0, 'negative', 'positive')

# calculate PRESS
library(qpcR)
Press <- PRESS(df2.lm)

# calculate TSS
Tss <- sum((df2$observed - mean(df2$observed))^2)

Q2 <- 1 - (Press$P.square/Tss)

# extract R2 from lm
R2 <- summary(df2.lm)$adj.r.squared 
```


```{r}
# plot prediction accuracy of plsr model
library(ggpmisc)
sp1 <- ggplot(df2, aes(x = observed, y = predicted)) +
  geom_point() +
  geom_smooth(method = lm, formula = y ~ x, se = FALSE) + 
  # stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
  #              label.x.npc = "right", label.y.npc = 0.15,
  #              formula = y ~ x, parse = TRUE, size = 3) +
  
  coord_fixed(ratio = 1,xlim = c(floor(min(df2$observed,df2$predicted)),
                 ceiling(max(df2$observed,df2$predicted))),
                 ylim = c(floor(min(df2$observed,df2$predicted)), ceiling(max(df2$observed,df2$predicted)))) +
  # coord_equal() +
  theme_bw() +
  labs(x = 'Observed GR50',
       y = 'Predicted GR50',
       title = '')

library(grid)
# Create a text
grob <- grobTree(textGrob(paste0('R2 = ',format(round(R2,2),nsmall = 2),
                                 '\nQ2 = ',
                                 format(round(Q2,2),nsmall = 2)),
                          x = 0.1,  
                          y = 0.90, 
                          hjust = 0,
                          gp = gpar(col = 'black', 
                                    fontsize = 10, 
                                    fontface = "italic")))

sp1 + annotation_custom(grob)
```


```{r}
# use PC score for ploting
scoredat <- data.frame('PC1' = myplsr2$scores[,1], # from component1
                       'PC2' = myplsr2$scores[,2], # from component2
                       'Cell' = List.cells,
                       'DR.Erlotinib' = drmxTrain$Erlotinib)

SS1 <- c('K213','K214','K156','HUCCA1','RBE','D138')
SS2 <- c('HuCCT1','TYBDC1','K055','D068','D131','TFK1','K100','YSCCC','SSP25')

subtype <- lapply(1:nrow(scoredat), function(x) {
  cellstr <- scoredat$Cell[x] #gsub('\\_.*','',new_scores$Cell[x])
  if (cellstr %in% SS1){
    Type <- 'S1'
  } else if (cellstr %in% SS2){
    Type <- 'S2'
  }})
#plot(myplsr2$scores[,2], myplsr2$scores[,5])

scoredat <- as.data.frame(append(scoredat,data.frame('subtype' = do.call(rbind,subtype))))

library(ggrepel)

ct_plsr <- ggplot(scoredat, aes(x = PC1, 
                   y = PC2)) +
  #geom_hline(yintercept = 0, colour = 'gray65') +
  #geom_vline(xintercept = 0, colour = 'gray65') +
  geom_point(aes(color = DR.Erlotinib, shape = factor(subtype)), size = 5) +
  #scale_size(breaks = c(-8,-6,-4,-2,0), labels = c(8,6,4,2,0)) +
  scale_color_gradient(low = 'blue', high = 'red') +
  geom_text_repel(aes(label = Cell), 
                  size = 3, 
                  alpha = 0.75,
                  box.padding = unit(0.5, 'lines'),
                  point.padding = 0.1,
                  segment.colour = 'gray60',
                  segment.size = 0.5,
                  segment.alpha = 0.5,
                  force = 2) +
  #guides(size = FALSE) +
  labs(x = paste0('PC1'),
       y = paste0('PC2'),
       colour = 'GR50',
       #size = 'sensitivity \n(IC50)',
       shape = 'Subtype',
       title = 'PLSR (NIPALS) of CCA subtypes \n and responses to  Erlotinib') +
  theme_bw()

ct_plsr
```


```{r}
## VIP returns all VIP values for all variables and all number of components,
## as a ncomp x nvars matrix.
VIP <- function(object) {
  if (object$method != "oscorespls")
    stop("Only implemented for orthogonal scores algorithm.  Refit with 'method = \"oscorespls\"'")
  if (nrow(object$Yloadings) > 1)
    stop("Only implemented for single-response models")
  
  SS <- c(object$Yloadings)^2 * colSums(object$scores^2)
  Wnorm2 <- colSums(object$loading.weights^2)
  SSW <- sweep(object$loading.weights^2, 2, SS / Wnorm2, "*")
  sqrt(nrow(SSW) * apply(SSW, 1, cumsum) / cumsum(SS))
}


## VIPjh returns the VIP of variable j with h components
VIPjh <- function(object, j, h) {
  if (object$method != "oscorespls")
    stop("Only implemented for orthogonal scores algorithm.  Refit with 'method = \"oscorespls\"'")
  if (nrow(object$Yloadings) > 1)
    stop("Only implemented for single-response models")
  
  b <- c(object$Yloadings)[1:h]
  Ta <- object$scores[,1:h, drop = FALSE]
  SS <- b^2 * colSums(Ta^2)
  W <- object$loading.weights[,1:h, drop = FALSE]
  Wnorm2 <- colSums(W^2)
  sqrt(nrow(W) * sum(SS * W[j,]^2 / Wnorm2) / sum(SS))
}
```


```{r}
# calculate VIP score
# use 'orscorepls' (NIPALS) algorithm
Input.pathway <- S1#tpmx2 #pmxTrain
Input.drug <- D1 #drmxTrain
# obtain number of pathways
num.pathway <- ncol(Input.pathway)
# obtain number of drugs
num.drug <- ncol(Input.drug)
# use function to find predicted values using PLSR model
vip.drug <- lapply(1:num.drug, function(n) {
  # define independent variable
  X <- Input.pathway
  # define dependent 
  Y <- as.data.frame(Input.drug[n])
  newdat <- cbind(Y, GE = I(as.matrix(X))) # this line is to create data input for pls package***
  num.prcomp <- nrow(newdat)
  colnames(newdat)[1] <- 'Drug'
  myplsr <- plsr(Drug ~ GE, num.prcomp-1, data = newdat, 
                 method = 'oscorespls',
                 scale = TRUE,
                 validation = 'LOO')
  # calculate VIP score of variable (pathway) per GR50 of the drug tested
  vip.score <- lapply(1:num.pathway, function(x) VIPjh(myplsr,x,myplsr$ncomp))
  vip.out <- as.data.frame(do.call(rbind,vip.score))
  colnames(vip.out)[1] <- colnames(Y)
  
  # calculate coef value of linear regression model based on observed and predicted variables from PC1 from PLSR
  add.sign <- lapply(1:num.pathway, function(p) {
    df2 <- data.frame('x' = newdat[,2][,p], 
                      'y' = newdat[,1])
    # create linear regression model
    df2.lm <- lm(y ~ x, data = df2)
    # extract coefficient value
    m <- df2.lm$coefficients[2]
    # determine whether coeff m is positive or negative
    if(m < 0) {
      value <- -vip.out[p,1]
    } else {
      value <- vip.out[p,1]
    }
    return(value)
  })
  vip.sign <- do.call(rbind,add.sign)
  vip.sign <- as.data.frame(vip.sign)
  colnames(vip.sign)[1] <- colnames(Y)
  
  # collect R2 from PLSR model
  dat.R2 <- R2(myplsr)
  # collect Mean Squared Prediction Error from PLSR model
  dat.MSEP <- MSEP(myplsr)
  
  vip.outputs <- list('VIPtable' = vip.out,
                      'R2' = dat.R2,
                      'MSPE' = dat.MSEP,
                      'VIPsign' = vip.sign)
  return(vip.outputs)
})
# VIP score matrix without sign
temp.mat <- lapply(1:length(vip.drug), function(q) {
  VIPscore <- vip.drug[[q]]$VIPtable
})

VIP.matrix <- do.call(cbind,temp.mat)
rownames(VIP.matrix) <- colnames(Input.pathway)

# VIP score matrix with sign
temp.mat2 <- lapply(1:length(vip.drug), function(r) {
  VIPsign <- vip.drug[[r]]$VIPsign
})

VIPsign.matrix <- do.call(cbind,temp.mat2)
rownames(VIPsign.matrix) <- colnames(Input.pathway)

```


```{r}
# Drug x Class matrix

drug.class <- read.csv('Drug_class.csv', header = TRUE, stringsAsFactors = FALSE)

drug.class <- drug.class[order(drug.class$Drug),]

class.unique <- unique(drug.class$Target)
# assign color to each drug class
library(RColorBrewer)
mypalette1 <- brewer.pal(12,'Set3')
mypalette2 <- brewer.pal(9,'Set1')
mypalette3 <- brewer.pal(8,'Set2')
mypalette4 <- brewer.pal(12,'Paired')

drug.class$class.color[grepl('Akt',drug.class$Target, fixed = FALSE)] <- mypalette1[1]
drug.class$class.color[grepl('CDK',drug.class$Target, fixed = FALSE)] <-  mypalette1[2]
drug.class$class.color[grepl('EGFR',drug.class$Target, fixed = FALSE)] <- mypalette1[3]
drug.class$class.color[grepl('IDH',drug.class$Target, fixed = FALSE)] <-  mypalette1[4]
drug.class$class.color[grepl('JNK',drug.class$Target, fixed = FALSE)] <- mypalette1[5]
drug.class$class.color[grepl('DNMT',drug.class$Target, fixed = FALSE)] <-  mypalette1[6]
drug.class$class.color[grepl('FGFR',drug.class$Target, fixed = FALSE)] <- mypalette1[7]
drug.class$class.color[grepl('mTOR',drug.class$Target, fixed = FALSE)] <-  mypalette1[8]
drug.class$class.color[grepl('NF-kB',drug.class$Target, fixed = FALSE)] <- mypalette1[9]
drug.class$class.color[grepl('PI3K',drug.class$Target, fixed = FALSE)] <-  mypalette1[10]
drug.class$class.color[grepl('DNA|cycle|Pyrimidine|alkylating|microtubule',drug.class$Target, fixed = FALSE)] <- mypalette1[11]
drug.class$class.color[grepl('Topo',drug.class$Target, fixed = FALSE)] <-  mypalette1[12]

drug.class$class.color[grepl('Hh|Wnt',drug.class$Target, fixed = FALSE)] <- mypalette2[1]
drug.class$class.color[grepl('Src|Abl',drug.class$Target, fixed = FALSE)] <-  mypalette2[2]
drug.class$class.color[grepl('Met',drug.class$Target, fixed = FALSE)] <- mypalette2[3]
drug.class$class.color[grepl('IAP',drug.class$Target, fixed = FALSE)] <-  mypalette2[4]
drug.class$class.color[grepl('secretase',drug.class$Target, fixed = FALSE)] <- mypalette2[5]
drug.class$class.color[grepl('HDAC',drug.class$Target, fixed = FALSE)] <-  mypalette2[6]
drug.class$class.color[grepl('MEK',drug.class$Target, fixed = FALSE)] <- mypalette2[7]
drug.class$class.color[grepl('JAK|STAT',drug.class$Target, fixed = FALSE)] <-  mypalette2[8]
drug.class$class.color[grepl('p38',drug.class$Target, fixed = FALSE)] <- mypalette2[9]

drug.class$class.color[grepl('PARP',drug.class$Target, fixed = FALSE)] <- mypalette3[1]
drug.class$class.color[grepl('MDM2',drug.class$Target, fixed = FALSE)] <-  mypalette3[2]
drug.class$class.color[grepl('IGF',drug.class$Target, fixed = FALSE)] <- mypalette3[3]
drug.class$class.color[grepl('IMPDH',drug.class$Target, fixed = FALSE)] <-  mypalette2[4]
drug.class$class.color[grepl('DHFR',drug.class$Target, fixed = FALSE)] <- mypalette3[5]
drug.class$class.color[grepl('HDAC',drug.class$Target, fixed = FALSE)] <-  mypalette3[6]
drug.class$class.color[grepl('PDGFR',drug.class$Target, fixed = FALSE)] <- mypalette3[7]
drug.class$class.color[grepl('BET',drug.class$Target, fixed = FALSE)] <-  mypalette3[8]

drug.class$class.color[grepl('GFGR',drug.class$Target, fixed = FALSE)] <- mypalette4[1]
drug.class$class.color[grepl('proteasome',drug.class$Target, fixed = FALSE)] <-  mypalette4[2]
drug.class$class.color[grepl('RTK',drug.class$Target, fixed = FALSE)] <- mypalette4[3]
drug.class$class.color[grepl('ALK',drug.class$Target, fixed = FALSE)] <-  mypalette4[4]
drug.class$class.color[grepl('RAF',drug.class$Target, fixed = FALSE)] <-  mypalette4[5]
```


```{r}
# VIP score heatmap
library(ComplexHeatmap)
# convert VIPsign to matrix class
df.VIP <- as.matrix(VIPsign.matrix)
# remove column in which entire rows contain NaN
df.VIP2 <- df.VIP[,colSums(!is.nan(df.VIP)) > 0]

df.VIP2[df.VIP2 > -1 & df.VIP2 < 1] <- 0

# # create legend annotation for drug target
# dt <- data.frame(Target = drug.class$Target)
# TargetColor <- drug.class$class.color
# names(TargetColor) <- drug.class$Target
# 
# # create heatmap annotation for drug class
# dc <- data.frame(Drug = drug.class$Drug)
# DrugColor <- drug.class$class.color
# names(DrugColor) <- drug.class$Drug
# 
# ha <- HeatmapAnnotation(df = dc,
#                         na_col = 'white',
#                         colname = anno_text(colnames(df.VIP2),
#                                             gp = gpar(fontsize = 6),
#                                             rot = 45,
#                                             just = "right",
#                                             offset = unit(1, "npc") - unit(2, "mm")),
#                         #col = list(Drug = DrugColor),
#                         annotation_height = unit.c(unit(5, "mm"), 
#                                                    max_text_width(colnames(df.VIP2)) + unit(2, "mm")),
#                         show_legend = FALSE)
# 
# has = columnAnnotation(df = dt, 
#                     na_col = 'white',
#                     annotation_legend_param = list(Target = list(ncol = 10, title = "Target", 
#                                                                  title_gp = gpar(fontsize = 10, 
#                                                                                  fontface = 'bold'),
#                                                                  labels_gp = gpar(fontsize = 8))),
#                     col = list(Target = TargetColor),
#                     show_legend = FALSE)

dff <- as.data.frame(df.VIP2)

Ht1 <- Heatmap(dff,
        cluster_rows = TRUE,
        clustering_distance_rows = 'spearman',
        clustering_method_rows = 'ward.D2',
        cluster_columns = FALSE,
        clustering_distance_columns = 'spearman',
        clustering_method_columns = 'ward.D2',
        row_title = 'Pathway',
        row_title_side = 'right',
        # figure title
        column_title = 'VIP by Drug Subtype 1',
        column_title_gp = gpar(fontsize = 20, fontface = "bold"),
        #column_title_side = 'bottom',
        heatmap_legend_param = list(title = 'VIP score', color_bar = 'discrete'),
        show_column_names = TRUE,
        show_row_names = TRUE,
        row_names_gp = gpar(fontsize = 8),
        column_names_gp = gpar(fontsize = 8))
        

draw(Ht1, heatmap_legend_side = 'bottom')
# must execute code in Console
for(an in colnames(dc)) {
    decorate_annotation(an, {
        # annotation names on the right
        #grid.text(an, unit(1, "npc") + unit(2, "mm"), 0.5, default.units = "npc", just = "left")
        # annotation names on the left
        grid.text(an, unit(0, "npc") - unit(2, "mm"), 0.5, default.units = "npc", just = "right")
    })
}
```


```{r}
# CCA subtype 2
# calculate VIP score
# use 'orscorepls' (NIPALS) algorithm
Input.pathway <- S2#tpmx2 #pmxTrain
Input.drug <- D2 #drmxTrain
# obtain number of pathways
num.pathway <- ncol(Input.pathway)
# obtain number of drugs
num.drug <- ncol(Input.drug)
# use function to find predicted values using PLSR model
vip.drug <- lapply(1:num.drug, function(n) {
  # define independent variable
  X <- Input.pathway
  # define dependent 
  Y <- as.data.frame(Input.drug[n])
  newdat <- cbind(Y, GE = I(as.matrix(X))) # this line is to create data input for pls package***
  num.prcomp <- nrow(newdat)
  colnames(newdat)[1] <- 'Drug'
  myplsr <- plsr(Drug ~ GE, num.prcomp-1, data = newdat, 
                 method = 'oscorespls',
                 scale = TRUE,
                 validation = 'LOO')
  # calculate VIP score of variable (pathway) per GR50 of the drug tested
  vip.score <- lapply(1:num.pathway, function(x) VIPjh(myplsr,x,myplsr$ncomp))
  vip.out <- as.data.frame(do.call(rbind,vip.score))
  colnames(vip.out)[1] <- colnames(Y)
  
  # calculate coef value of linear regression model based on observed and predicted variables from PC1 from PLSR
  add.sign <- lapply(1:num.pathway, function(p) {
    df2 <- data.frame('x' = newdat[,2][,p], 
                      'y' = newdat[,1])
    # create linear regression model
    df2.lm <- lm(y ~ x, data = df2)
    # extract coefficient value
    m <- df2.lm$coefficients[2]
    # determine whether coeff m is positive or negative
    if(m < 0) {
      value <- -vip.out[p,1]
    } else {
      value <- vip.out[p,1]
    }
    return(value)
  })
  vip.sign <- do.call(rbind,add.sign)
  vip.sign <- as.data.frame(vip.sign)
  colnames(vip.sign)[1] <- colnames(Y)
  
  # collect R2 from PLSR model
  dat.R2 <- R2(myplsr)
  # collect Mean Squared Prediction Error from PLSR model
  dat.MSEP <- MSEP(myplsr)
  
  vip.outputs <- list('VIPtable' = vip.out,
                      'R2' = dat.R2,
                      'MSPE' = dat.MSEP,
                      'VIPsign' = vip.sign)
  return(vip.outputs)
})
# VIP score matrix without sign
temp.mat <- lapply(1:length(vip.drug), function(q) {
  VIPscore <- vip.drug[[q]]$VIPtable
})

VIP.matrix <- do.call(cbind,temp.mat)
rownames(VIP.matrix) <- colnames(Input.pathway)

# VIP score matrix with sign
temp.mat2 <- lapply(1:length(vip.drug), function(r) {
  VIPsign <- vip.drug[[r]]$VIPsign
})

VIPsign.matrix <- do.call(cbind,temp.mat2)
rownames(VIPsign.matrix) <- colnames(Input.pathway)

```

```{r}
# VIP score heatmap
library(ComplexHeatmap)
# convert VIPsign to matrix class
df.VIP <- as.matrix(VIPsign.matrix)
# remove column in which entire rows contain NaN
df.VIP2 <- df.VIP[,colSums(!is.nan(df.VIP)) > 0]

df.VIP2[df.VIP2 > -1 & df.VIP2 < 1] <- 0

# # create legend annotation for drug target
# dt <- data.frame(Target = drug.class$Target)
# TargetColor <- drug.class$class.color
# names(TargetColor) <- drug.class$Target
# 
# # create heatmap annotation for drug class
# dc <- data.frame(Drug = drug.class$Drug)
# DrugColor <- drug.class$class.color
# names(DrugColor) <- drug.class$Drug
# 
# ha <- HeatmapAnnotation(df = dc,
#                         na_col = 'white',
#                         colname = anno_text(colnames(df.VIP2),
#                                             gp = gpar(fontsize = 6),
#                                             rot = 45,
#                                             just = "right", 
#                                             offset = unit(1, "npc") - unit(2, "mm")),
#                         col = list(Drug = DrugColor),
#                         annotation_height = unit.c(unit(5, "mm"), 
#                                                    max_text_width(colnames(df.VIP2)) + unit(2, "mm")),
#                         show_legend = FALSE)
# 
# has = rowAnnotation(df = dt, 
#                     na_col = 'white',
#                     annotation_legend_param = list(Target = list(ncol = 10, title = "Target", 
#                                                                  title_gp = gpar(fontsize = 10, 
#                                                                                  fontface = 'bold'),
#                                                                  labels_gp = gpar(fontsize = 8))),
#                     col = list(Target = TargetColor))

dff2 <- as.data.frame(df.VIP2)

Ht2 <- Heatmap(dff2,
        cluster_rows = TRUE,
        clustering_distance_rows = 'spearman',
        clustering_method_rows = 'ward.D2',
        cluster_columns = FALSE,
        clustering_distance_columns = 'spearman',
        clustering_method_columns = 'ward.D2',
        row_title = 'Pathway',
        row_title_side = 'right',
        # figure title
        column_title = 'VIP by Drug Subtype 2',
        column_title_gp = gpar(fontsize = 20, fontface = "bold"),
        #column_title_side = 'bottom',
        heatmap_legend_param = list(title = 'VIP score', color_bar = 'discrete'),
        show_column_names = TRUE,
        show_row_names = TRUE,
        row_names_gp = gpar(fontsize = 8),
        column_names_gp = gpar(fontsize = 8))

draw(H2 + has, heatmap_legend_side = 'bottom')
# must execute code in Console
for(an in colnames(dc)) {
    decorate_annotation(an, {
        # annotation names on the right
        #grid.text(an, unit(1, "npc") + unit(2, "mm"), 0.5, default.units = "npc", just = "left")
        # annotation names on the left
        grid.text(an, unit(0, "npc") - unit(2, "mm"), 0.5, default.units = "npc", just = "right")
    })
}
```







```{r}
# Categorial data of CCA cell lines
# assign categorical values
# tissueType
CCA <- c('K055','K100','K156','K213','K214','D068','D131','D138','HuCCT1','HUCCA1','MMNK1','RBE','SSP25','SSP25R','TFK1','TYBDC1','X055R','X214R','YSCCC')
BRS <- c('MCF7','T47D','T47DR','ZR751')
HEP <- c('Huh28')
# normal
NORM <- c('MCF7','T47D','ZR751','MMNK1')
# Drug resistant
RESIST <- c('SSP25R','X055R','X214R','T47DR')
# Drug responses subgroups
DRGROUP1 <- c('K213','K214','K156','HUCCA1','RBE','D138')
DRGROUP2 <- c('K055','K100','D068','D131','HuCCT1','SSP25','TFK1','TYBDC1','YSCCC')
```


```{r}
# ignore this section for now
prepmat <- function(dat, cutoff) {
  H.matrix <- dat
  cf <- cutoff
  # create heatmap displaying NES of KEGG pathways from all cell lines
  Btable <- H.matrix
  
  DRGROUP1 <- c('K213','K214','K156','HUCCA1','RBE','D138')
  DRGROUP2 <- c('K055','K100','D068','D131','HuCCT1','SSP25','TFK1','TYBDC1','YSCCC')
  
  matrix <- Btable %>% select_('ID','Description','Cell','NES') %>% droplevels()
  matrix <- Btable %>% filter(Cell %in% c(DRGROUP1,DRGROUP2)) %>% select_('ID','Description','Cell','NES') %>% droplevels
  
  library(reshape2)
  mx <- dcast(matrix, ID + Description ~ Cell, value.var = 'NES')
  mx[is.na(mx)] <- 0
  mxx <- mx[,3:17]
  mxx <- as.data.frame(mxx)
  rownames(mxx) <- mx$Description
  # count number of zero per row and remove the rows of zero number is larger than 80% of cell lines
  mxx <- mxx[rowSums(mxx == 0) <= (ncol(mxx)-floor(ncol(mxx)*cf)), ] 
}
```

```{r}
# ignore this section for now
# generate NES matrix according to different database
prepmat.HM <- prepmat(H.matrix,0.8)
prepmat.BP <- prepmat(BP.matrix,0.8)
prepmat.CP <- prepmat(CP.matrix,0.8)
prepmat.KG <- prepmat(KG.matrix,0.8)
prepmat.OS <- prepmat(OS.matrix,0.8)
```

```{r}
# ignore this section for now
library(RColorBrewer)
CC <- colorspace::diverge_hsv(12)
breaksList <- seq(-3,3, by = 0.50)

# breaksList = seq(-2, 2, by = 4/11)
# cols <- rev(RColorBrewer::brewer.pal(11,'RdYlGn'))

library(pheatmap)
ct_hp <- pheatmap(mxx, 
                  scale = 'row',       # 'row' 'column' 'none'
                  cluster_rows = TRUE,                    # boolean for cluster by rows
                  cluster_cols = TRUE,                    # boolean for cluster by columns
                  clustering_method = 'ward.D2',          # method for clustering
                  clustering_distance_rows = 'euclidean', # use euclidean distance
                  clustering_distance_cols = 'euclidean', # use euclidean distance
                  cellwidth = 10,                         # set cell width
                  cellheight = 6,                       # set cell height
                  treeheight_row = 10,
                  treeheight_col = 5,
                  #cutree_rows = 3,                        # set break gap between rows
                  #cutree_cols = 5,                        # set break gap between columns
                  show_colnames = TRUE,                   # boolean for showing column names
                  show_rownames = TRUE,                  # boolean for showing row names
                  annotation_names_col = TRUE,            # boolean for showing column annotation
                  main = 'Hallmarks Gene Sets of CCA',
                  fontsize = 6,
                  color = CC,                           # color codes used in this heatmap
                  breaks = breaksList)
```

```{r}
# ignore this section for now
Heatmap.NES <- function(dat,title){
  # reorder columns according to subtypes defined by drug responses
  library(data.table)
  mxx <- dat
  mxx.re <- data.table(mxx)
  setcolorder(mxx.re, c(DRGROUP1,DRGROUP2))
  mxx.re <- as.data.frame(mxx.re)
  rownames(mxx.re) <- rownames(mxx)
  
  main <- paste0(as.character(title),' Gene Set Enrichment Analysis')
  
  row.count <- nrow(mxx.re)
  cell.height <- row.count/(4^(row.count/40))
  if (cell.height < 0.8){
    ch <- 0.8
  } else{
    ch <- cell.height
  }

library(pheatmap)
ct_hpuc <- pheatmap(mxx.re, 
                  scale = 'row',       # 'row' 'column' 'none'
                  cluster_rows = TRUE,                    # boolean for cluster by rows
                  cluster_cols = FALSE,                    # boolean for cluster by columns
                  clustering_method = 'ward.D2',          # method for clustering
                  clustering_distance_rows = 'euclidean', # use euclidean distance
                  clustering_distance_cols = 'euclidean', # use euclidean distance
                  cellwidth = 10,                         # set cell width
                  cellheight = ch,                       # set cell height
                  treeheight_row = 10,
                  treeheight_col = 5,
                  #cutree_rows = 3,                        # set break gap between rows
                  #cutree_cols = 6,                        # set break gap between columns
                  show_colnames = TRUE,                   # boolean for showing column names
                  show_rownames = FALSE,                  # boolean for showing row names
                  annotation_names_col = TRUE,            # boolean for showing column annotation
                  main = main, 
                  fontsize = 8,
                  color = CC,                           # color codes used in this heatmap
                  breaks = breaksList)
}
```

```{r}
# ignore this section for now
fig_HM <- Heatmap.NES(prepmat.HM,'Hallmarks')
fig_BP <- Heatmap.NES(prepmat.BP,'Biological Process')
fig_KG <- Heatmap.NES(prepmat.KG,'KEGG pathway')
fig_CP <- Heatmap.NES(prepmat.CP,'Canonical pathway')
fig_OS <- Heatmap.NES(prepmat.OS,'Oncogenic signaling')
```

```{r}
# ignore this section for now
# select top 10 pathways up- and down-regulated
H.matrix

NES.K055 <- H.matrix %>% filter(Cell %in% c('K055'))

topPathwaysUp <- fgseaRes[ES > 0][head(order(pval), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(pval), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(examplePathways[topPathways], exampleRanks, fgseaRes, 
              gseaParam = 0.5)
```

