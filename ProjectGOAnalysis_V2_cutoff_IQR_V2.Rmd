---
title: "CCA-Heterogeneity"
author: "Pat Kueanjinda"
date: "June 2, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

---
title: "CCA RNA-seq"
output:
  html_document:
    df_print: paged
---

```{r}
library(dplyr)
library(tidyr)
library(DOSE)
library(enrichplot)
library(org.Hs.eg.db)
library(xlsx)
```

```{r}
setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq')

mydf <- read.csv('Gene_Expression_Matrix.csv', header = TRUE, stringsAsFactors = FALSE)
# remove columns where ALL rows are NA
df <- mydf[,colSums(is.na(mydf)) < nrow(mydf)]

myGR50 <- read.csv('SubMedianLog10GR50.csv', header = TRUE, stringsAsFactors = FALSE)

```

```{r}
# apply cut-off at percentile 50th 
# select only CCA cell lines
# Drug responses subgroups
S1 <- c('K213','K214','K156','HUCCA1','RBE','D138')
S2 <- c('K055','K100','D068','D131','HuCCT1','SSP25','TFK1','TYBDC1','YSCCC')
# combind cell group 1 + group 2
cell.CCA <- c(S1,S2)
# find column locations of cells
cell.location <- which(colnames(df) %in% cell.CCA)
# subset cells using column locations
df.mat <- df[,c(1,cell.location)]
# transform data using log2 scale
dflog.mat <- log2(df.mat[,-c(1)])
# replace Inf/-Inf with zero
dflog.mat[!is.finite(as.matrix(dflog.mat))] <- 0
# convert to dataframe with headers from df.mat
df.mat2 <- data.frame(dflog.mat, row.names = df.mat[,1])
# calculate quartile 50th
QT50.mat <- apply(df.mat2[,-c(1)],1, function(i) {quantile(i,0.5)})
# add quartile 50th column
QT50.df <- data.frame('QT50' = QT50.mat)
# reassemble a dataframe 
df.mat3 <- cbind(QT50.df,df.mat2)
# remove gene in rows using data from column when QT50 < 0
df.mat4 <- df.mat3[df.mat3$QT50 > 0,] 
# remove QT50 column
df.mat4 <- df.mat4[,-c(1)]
```


```{r}
# function for normalization using group median expression value
normfun <- function(D) {
  d <- as.numeric(D)
  #row.IQR <- IQR(d, type = 2)
  row.median <- median(d)
  #row.value <- (d - row.median)/row.IQR # Dision with row.IQR will stretch gene group's variance
  row.value <- (d - row.median)
}
```

```{r}
# normalize with median of gene group
df.norm <- t(apply(df.mat4, 1, normfun))
df.norm[!is.finite(df.norm)] <- 0
colnames(df.norm) <- colnames(df.mat4)

```

```{r}
# Now, we will generate a column of values resulting from a comparison between Subtype 1 and Subtype 2
S1 <- c('K213','K214','K156','HUCCA1','RBE','D138')
S2 <- c('K055','K100','D068','D131','HuCCT1','SSP25','TFK1','TYBDC1','YSCCC')
# expresion value dataframe
df.new <- df.norm
# separate CCA subtype
loc.S1 <- which(colnames(df.new) %in% S1)
loc.S2 <- which(colnames(df.new) %in% S2)
# calculate median of each subtype
median.S1 <- apply(df.new[,loc.S1], 1, median)
median.S2 <- apply(df.new[,loc.S2], 1, median)
# Interstingly, the median of fold-change of mRNA expression of all genes is zero
viz <- apply(df.new, 1, median)
df.viz <- as.data.frame(viz)
# display frequency of numbers found in the data frame
table(df.viz)
```


```{r}
# Therefore, the median values of S1 and S2 can represent the distant of S1 and S2's median from the median center
# Now, we will calculate how large the median expression of S1 differs from median expression of S2
fc.subtypes <- median.S1 - median.S2
df.subtypes <- data.frame('Subtype_1.2' = fc.subtypes)

```

```{r}
# Now, we will generate a column of values resulting from a comparison between MEK sensitive and MEK resistant cells
# MEK inhibitor TAK733
# We will use GR50 as sensitivity determination
TKS <- myGR50 %>% filter(TAK733 < 0) %>% select_('X')
TKR <- myGR50 %>% filter(TAK733 > 0) %>% select_('X')
# identify column numbers using data from list of MEK sensitive and Resistant cells
loc.TKS <- which(colnames(df.new) %in% TKS$X)
loc.TKR <- which(colnames(df.new) %in% TKR$X)
# calculate median of each subtype
median.TKS <- apply(df.new[,loc.TKS], 1, median)
median.TKR <- apply(df.new[,loc.TKR], 1, median)

fc.TAK733 <- median.TKS - median.TKR
df.TAK733 <- data.frame('TAK733_S.R' = fc.TAK733)
```

```{r}
# MEK inhibitor PD0325901
PDS <- myGR50 %>% filter(PD0325901 < 0) %>% select_('X')
PDR <- myGR50 %>% filter(PD0325901 > 0) %>% select_('X')
# identify column numbers using data from list of MEK sensitive and Resistant cells
loc.PDS <- which(colnames(df.new) %in% PDS$X)
loc.PDR <- which(colnames(df.new) %in% PDR$X)
# calculate median of each subtype
median.PDS <- apply(df.new[,loc.PDS], 1, median)
median.PDR <- apply(df.new[,loc.PDR], 1, median)

fc.PD0325901 <- median.PDS - median.PDR
df.PD0325901 <- data.frame('PD0325901_S.R' = fc.PD0325901)
```

```{r}
# Src inhibitor Selumetinib
SLS <- myGR50 %>% filter(Selumetinib < 0) %>% select_('X')
SLR <- myGR50 %>% filter(Selumetinib > 0) %>% select_('X')
# identify column numbers using data from list of MEK sensitive and Resistant cells
loc.SLS <- which(colnames(df.new) %in% SLS$X)
loc.SLR <- which(colnames(df.new) %in% SLR$X)
# calculate median of each subtype
median.SLS <- apply(df.new[,loc.SLS], 1, median)
median.SLR <- apply(df.new[,loc.SLR], 1, median)

fc.Selumetinib <- median.SLS - median.SLR
df.Selumetinib <- data.frame('Selumetinib_S.R' = fc.Selumetinib)
```

```{r}
# Src/Abl inhibitor Dasatinib
DSS <- myGR50 %>% filter(Dasatinib < 0) %>% select_('X')
DSR <- myGR50 %>% filter(Dasatinib > 0) %>% select_('X')
# identify column numbers using data from list of MEK sensitive and Resistant cells
loc.DSS <- which(colnames(df.new) %in% DSS$X)
loc.DSR <- which(colnames(df.new) %in% DSR$X)
# calculate median of each subtype
median.DSS <- apply(df.new[,loc.DSS], 1, median)
median.DSR <- apply(df.new[,loc.DSR], 1, median)

fc.Dasatinib <- median.DSS - median.DSR
df.Dasatinib <- data.frame('Dasatinib_S.R' = fc.Dasatinib)
```

```{r}
# We will add these drug response columns to to original data frame
df.new2 <- cbind(df.norm, df.subtypes, df.TAK733, df.PD0325901, df.Selumetinib, df.Dasatinib)
```

```{r}
# we already have dataframe containing fold-change value compared to median of gene group
# Next, we'll find hallmarks based on these values
# recall function for geneID mapping
# add ENTREZID column
addENTREZID <- function(dat) {
  library(data.table)
  df.new <- setDT(as.data.frame(dat),keep.rownames = TRUE)[]
  setnames(df.new,1,'Gene.name')
  df.new <- as.data.frame(df.new)
  List.col2 <- colnames(df.new)
  loc.symbol <- which(List.col2 == 'Gene.name')
  library(clusterProfiler)
  md <- bitr(df.new[,loc.symbol], fromType = 'SYMBOL', toType = c('ENTREZID'), OrgDb = 'org.Hs.eg.db')
  
  # now get values from all CCA 
  df.sel <- df.new %>% filter(Gene.name %in% md$SYMBOL) %>% 
    select_(.dots = colnames(df.new))
  
  mc <- bitr(df.sel$Gene.name, fromType = 'SYMBOL', toType = 'ENTREZID', OrgDb = 'org.Hs.eg.db')
  mc.uq <- mc[!duplicated(mc$SYMBOL),]
  df.out <- as.data.frame(append(df.sel,data.frame('ENTREZID' = mc.uq$ENTREZID) , after = loc.symbol))
  colnames(df.out)[1] <- 'SYMBOL'
  return(df.out)
}
```

```{r}
# generate dataframe with ENTREZID
# This format is compatible with Broad Institute's GSEA
df.B <- addENTREZID(df.new2)
colnames(df.B)[c(1,2)] <- c('NAME','DESCRIPTION')
# save file
#write.table(df.B, file = 'GSEA_Matrix_Broad.txt', row.names = FALSE, quote = FALSE, sep = "\t")

```

```{r}
# We need to crate databases for GSEA
# Here, we will MSigDB for gene sets
library(GSEABase)
db.path <- 'C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq'
db.folder <- 'msigdb_v6.1_files_local/msigdb_v6.1_GMTs'
db.list <- list.files(file.path(db.path,db.folder), pattern = '\\.entrez.gmt$')

gmtfile.hm <- file.path(db.path,db.folder,db.list[20])
db1 <- read.gmt(gmtfile.hm) #Hallmarks data set

gmtfile.bp <- file.path(db.path,db.folder,db.list[15])
db2 <- read.gmt(gmtfile.bp)#Biological processes data set

gmtfile.kg <- file.path(db.path,db.folder,db.list[5])
db3 <- read.gmt(gmtfile.kg) #KEGG pathways data set

gmtfile.cp <- file.path(db.path,db.folder,db.list[7])
db4 <- read.gmt(gmtfile.cp) #Cellular processes data set

gmtfile.os <- file.path(db.path,db.folder,db.list[18])
db5 <- read.gmt(gmtfile.os) #Oncogenic pathways data set

db.list
```


```{r}
# We will perform GSEA using functions in DOSE package
# First, we will create a custom function that will extract a table report similar to one in Broad Institute's GSEA
myenrich <- function(df,col.ENTREZID,col.cell,p.cutoff,db,f.switch){
  List.col <- colnames(df)
  num.cell <- length(col.cell)
  List.gseKEGG <- lapply(1:num.cell, function(i) {
    df.cell <- df %>% select_(.dots = List.col[c(col.ENTREZID,col.cell[i])])
    v <- df.cell[,2] # data were already applied log2
    v[!is.finite(v)] <- 0 # non-finite values = 0
    names(v) <- df.cell[,1] # use ENTREZID as rownames
    vin <- sort(v, decreasing = TRUE) # sort based on value
    
    kk2 <- GSEA(vin, 
                exponent = 1, 
                nPerm = 1000, 
                minGSSize = 10, 
                maxGSSize = 500, 
                pvalueCutoff = p.cutoff, 
                pAdjustMethod = "BH", 
                TERM2GENE = db,
                TERM2NAME = NA, 
                verbose = FALSE, 
                seed = FALSE)
    
    kk2 <- setReadable(kk2, OrgDb = org.Hs.eg.db, keytype = 'ENTREZID') # convert ENTREZID to SYMBOL, require clusterprofiler package
    cell.gseKEGG <- kk2@result # extract table result from class kk2
    if (f.switch == 1){
      Sig.cell.gseKEGG <- cell.gseKEGG %>% filter(grepl('.*signaling pathway',Description)) # filter rows with term 'signaling pathway'
      library(tm) # NLP package
      mi <- Sig.cell.gseKEGG$Description
      mt <- removeWords(as.character(mi),'signaling pathway')
      mc <- rep(List.col[col.cell[i]], length(mi))
      loc.add <- which(colnames(Sig.cell.gseKEGG) == 'Description')
      Sig.cell.gseKEGG <- as.data.frame(append(Sig.cell.gseKEGG, data.frame('ShortDescription' = mt,
                                                                            'Cell' = mc), after = loc.add))
    } else {
      Sig.cell.gseKEGG <- cell.gseKEGG
      mi <- Sig.cell.gseKEGG$Description
      mc <- rep(List.col[col.cell[i]], length(mi))
      loc.add <- which(colnames(Sig.cell.gseKEGG) == 'Description')
      Sig.cell.gseKEGG <- as.data.frame(append(Sig.cell.gseKEGG, data.frame('Cell' = mc), after = loc.add))
    }
    outputs <- list('table' = Sig.cell.gseKEGG,
                    'gseKEGG' = kk2)
    return(outputs)
  })
  Table.gseKEGG <- do.call(rbind,lapply(1:length(List.gseKEGG), function(x) List.gseKEGG[[x]]$table))
  gsea.output <- lapply(1:length(List.gseKEGG), function(x) List.gseKEGG[[x]]$gseKEGG)
  finals <- list('table' = Table.gseKEGG,
                 'gsea' = gsea.output)
  return(finals)
}
```


```{r}
# We are focusing on GSEA using Hallmarks data set
# define input data frame
Param1 <- df.B
# define ENTREZID column number
Param2 <- 2
# define Cell column numbers
Param3 <- 3:ncol(df.B)
# define p-value cutoff
Param4 <- 0.05
# define data set used in this analysis
Param5 <- db1
```

```{r}
# Set initial p-value cutoff = 0.05
# number of cells with significant hallmarks
i <- 1
for (i in c(1:ncol(Param1))) {
  if (i < ncol(Param1) | Param4 < 1) {
    HM <- myenrich(Param1,
                   col.ENTREZID = Param2,
                   col.cell = Param3,
                   p.cutoff = Param4,
                   db = Param5,
                   f.switch = 0)
    HT <- HM$table
    i <- length(unique(HT$Cell))
    Param4 <- Param4 + 0.05
  }}

print(Param4)
      
# If number of cells with significant hallmarks does not reach 12, we need to adjust p-value cutoff
```


```{r}
# Add Type column to identify cell factor
HT2 <- mutate(HT, FACTOR = ifelse(Cell %in% S1, 'Subtype1', 
                                  ifelse(Cell %in% S2, 'Subtype2',
                                         ifelse(Cell %in% c('Subtype_1.2'), 'CellType',
                                                ifelse(Cell %in% c('TAK733_S.R','PD0325901_S.R'), 'MEKi','SRCi')))))

```

```{r}
setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq')
write.csv(HT2,'Hallmarks_Matrix_Original.csv',row.names = FALSE, quote = FALSE)
```


```{r}
# filter NES matrix of hallmarks with FDR qvalue < 0.25
sel25 <- HT2 %>% filter(qvalues < 0.25)

# subset data using column names
Sig <- sel25 %>% select_('ID','Cell','FACTOR','NES','p.adjust','qvalues','core_enrichment')
# convert p-value to significant level (smaller p-value, the larger number)
Sig$log2.p.adjust <- -log2(Sig$p.adjust)
# assign  factor level to cell
Sig$Cell <- factor(Sig$Cell)
Sig$FACTOR <- factor(Sig$FACTOR)

Sig$facet = factor(Sig$FACTOR, levels = c('Subtype1','Subtype2','CellType','MEKi','SRCi'))


```

```{r}
setwd('C:/Users/patipark/Dropbox/CCA project/CCA RNA-seq')
write.csv(Sig, file = 'Matrix_for_raster_plots.csv', row.names = FALSE, quote = FALSE)

```

```{r}
library(colorRamps)
CellColors <- colorRamps::primary.colors(length(unique(Sig$Cell)))

my.colorgradient <- rev(RColorBrewer::brewer.pal(7,'RdYlGn'))
  
  #c('#b2192b','#ef8a62','#fddbc7','#f7f7f7','#d1e5f0','#67a9cf','#2166ac')
```

```{r}
library(ggplot2)
#Sig.sort <- Sig[order(Sig$p.adjust),]
ct_fig1 <- ggplot(Sig, aes(x = Cell, # GR column on x-axis
                           y = ID,
                           fill = NES)) + # reorder(ID,log2.p.adjust)
  #scale_shape_manual(values = 1:nlevels(Sig$Cell)) +
  facet_wrap(~ facet, scales = 'free_x',drop = TRUE, nrow = 1, ncol = 5, strip.position = 'top') +
  geom_point(aes(size = log2.p.adjust), pch = 21) +
  scale_fill_gradient2(low = 'green',
                       midpoint = 0,
                       mid = 'white',
                       high = 'red',
                       space = 'Lab',
                       breaks = c(-2,-1,0,1,2),
                       limits = c(-2,2),
                       oob = scales::squish,
                       na.value = 'gray50') +
  theme_minimal() +
  theme(axis.text.x = element_text(
    face = 'plain', color = 'black', 
    size = 10, angle = 45,
    vjust = 1, hjust = 1),
    axis.text.y = element_text(
      face = 'plain', color = 'black',
      size = 5, angle = 0),
    panel.border = element_rect(fill = NA, colour = 'black')) +
  labs(x = NULL,
       y = NULL,
       size = expression(Significance~level),
       color = expression(NES~score))
  
```
